// Copyright (c) Kk Shinkai. All Rights Reserved. See LICENSE.txt in the project
// root for license information.

use std::path::PathBuf;

/// Represents the path to a source file. Can only be created by [`SourceMap`].
///
/// This path, unlike [`PathBuf`] and [`Path`], represents a file that can be
/// read without problems.
///
/// We should not provide the method to create the [`SourcePath`] publicly. All
/// source paths should be generated by [`SourceMap`].
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct SourcePath {
    kind: SourcePathKind,
}

impl SourcePath {
    pub(super) fn local_file(path: PathBuf) -> SourcePath {
        SourcePath {
            kind: SourcePathKind::Local(path)
        }
    }

    pub(super) fn test_file(name: Option<String>, uid: u32) -> SourcePath {
        SourcePath {
            kind: SourcePathKind::Test { name, uid }
        }
    }

    pub(super) fn is_local_file(&self) -> bool {
        matches!(self.kind, SourcePathKind::Local(_))
    }

    pub(super) fn is_test_file(&self) -> bool {
        matches!(self.kind, SourcePathKind::Test { .. })
    }

    pub(super) fn readable_name(&self) -> String {
            match self.kind {
                SourcePathKind::Local(ref path) => {
                    // Rust `std::fs::canonicalize` returns Windows NT UNC paths on
                    // Windows (e.g. `\\?\C:\example.txt`), which are rarely
                    // supported by Windows programs, even Microsoft's own. Just
                    // remove the verbatim prefix.
                    //
                    // This path is already canonicalized, so we don't need to
                    // verify it again.
                    //
                    // TBD: Maybe we should use `std::path::absolute` (unstable)
                    // instead of `std::fs::canonicalize`?
                    #[cfg(windows)]
                    {
                        use std::path::{Component, Prefix};
                        if let Some(Component::Prefix(p)) = path.components().next() {
                            if matches!(p.kind(), Prefix::VerbatimDisk(..)) {
                                // This string if always longer than 4 on Windows
                                // because it is canonicalized.
                                return path.to_string_lossy()[4..].to_string();
                            }
                        }
                    }

                    path.to_string_lossy().to_string()
                },
                SourcePathKind::Test { ref name, uid } => match name {
                    Some(name) => name.clone(),
                    None => format!("virtual #{}", uid),
                },
            }
    }
}

#[derive(Clone, PartialEq, Eq, Hash)]
enum SourcePathKind {
    /// The canonical, unique path to an existing local file. The path must be
    /// canonicalized by [`std::fs::canonicalize`].
    Local(PathBuf),

    /// A dummy file with given name, mostly for testing.
    Test {
        /// An optional name for the testing source snippet.
        name: Option<String>,

        /// An unique number to distinguish the testing snippet from others.
        uid: u32,
    },
}
