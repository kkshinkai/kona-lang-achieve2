// Copyright (c) Kk Shinkai. All Rights Reserved. See LICENSE.txt in the project
// root for license information.

use std::fmt;
use std::ops::{Add, Sub, AddAssign, SubAssign};

/// Represents a position of code text in the source map.
#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Pos {
    index: u32,
}

impl Pos {
    /// Creates a new `Pos` with the given `u32` without validation.
    #[inline(always)]
    pub fn from_u32(index: u32) -> Pos {
        // NOTE: I didn't use the name `new` because I thought the name
        //       `from_u32` might make it clearer to the user that this is an
        //       unverified forced conversion. I didn't implement the
        //       `From<u32>` trait for the same reason.
        Pos { index }
    }

    /// Returns the inner `u32` of the `Pos`.
    #[inline(always)]
    pub fn to_u32(self) -> u32 {
        self.index
    }

    /// Creates a new `Pos` with the given `usize` without validation.
    ///
    /// Since the internal representation of `Pos` is `u32`, the conversion from
    /// `usize` might not be safe. But we don't need to check too much on it,
    /// [`SourceMap`] will make sure all files are less than 4GB (2^32 Bytes)
    /// when reading them. `Pos` generated by [`SourceMap`] will not overflow.
    #[inline(always)]
    pub fn from_usize(index: usize) -> Pos {
        Pos { index: index as u32 }
    }

    /// Returns the inner `usize` of the `Pos`.
    #[inline(always)]
    pub fn to_usize(self) -> usize {
        self.index as usize
    }
}

impl fmt::Debug for Pos {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Pos({})", self.index)
    }
}

// NOTE: Never implement `Add` and `Sub` for `Pos`. Adding two `Pos` together
//       is meaningless, just like adding two raw pointers. Implement `Add<u32>`
//       and `Sub<u32>` instead, here `u32` is considered as offset.
//
//           add, sub: Fn(Pos, usize) -> Pos   // ✓
//           add, sub: Fn(Pos, Pos) -> Pos     // ✗
//
//       For convenience, `Add<usize>` and `Sub<usize>` are also implemented.

impl Add<usize> for Pos {
    type Output = Pos;

    #[inline(always)]
    fn add(self, offset: usize) -> Pos {
        Pos::from_u32(self.index + offset as u32)
    }
}

impl AddAssign<usize> for Pos {
    #[inline(always)]
    fn add_assign(&mut self, offset: usize) {
        self.index += offset as u32;
    }
}

impl Sub<usize> for Pos {
    type Output = Pos;

    #[inline(always)]
    fn sub(self, offset: usize) -> Pos {
        Pos::from_u32(self.index - offset as u32)
    }
}

impl SubAssign<usize> for Pos {
    #[inline(always)]
    fn sub_assign(&mut self, offset: usize) {
        self.index -= offset as u32;
    }
}


impl Add<u32> for Pos {
    type Output = Pos;

    #[inline(always)]
    fn add(self, offset: u32) -> Pos {
        Pos::from_u32(self.index + offset)
    }
}

impl AddAssign<u32> for Pos {
    #[inline(always)]
    fn add_assign(&mut self, offset: u32) {
        self.index += offset;
    }
}

impl Sub<u32> for Pos {
    type Output = Pos;

    #[inline(always)]
    fn sub(self, offset: u32) -> Pos {
        Pos::from_u32(self.index - offset)
    }
}

impl SubAssign<u32> for Pos {
    #[inline(always)]
    fn sub_assign(&mut self, offset: u32) {
        self.index -= offset as u32;
    }
}

